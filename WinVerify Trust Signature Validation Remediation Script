<# 
Remediate-TenableFindings.ps1
Targets (from Tenable report):
- 166555 WinVerifyTrust Signature Validation CVE-2013-3900 Mitigation (EnableCertPaddingCheck)
- 132101 Windows Speculative Execution Configuration Check
- 57608  SMB Signing not required (Client/Server)
- 57582  SSL Self-Signed Certificate  (assist/report; optional replace)
- 51192  SSL Certificate Cannot Be Trusted (refresh roots / assist)
- 10114  ICMP Timestamp Request Remote Date Disclosure (block ICMP types 13/14)

Run as Administrator. Some changes require reboot to fully apply (noted at end).
#>

[CmdletBinding(SupportsShouldProcess)]
param(
  [switch]$ReportOnly,            # No changes, just show intended actions
  [switch]$ReplaceSelfSignedCerts # Dangerous: replaces machine self-signed certs with new ones (IIS/RDP not auto-bound)
)

function Assert-Admin {
  $current = [Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()
  if (-not $current.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    throw "Please run this script in an elevated PowerShell session."
  }
}

function Start-RemediationLog {
  $global:TranscriptPath = Join-Path $env:TEMP ("Remediate-TenableFindings_{0:yyyyMMdd_HHmmss}.log" -f (Get-Date))
  try { Start-Transcript -Path $TranscriptPath -ErrorAction Stop | Out-Null } catch {}
}

function Set-RegistryDword {
  param(
    [Parameter(Mandatory)] [string]$Path,
    [Parameter(Mandatory)] [string]$Name,
    [Parameter(Mandatory)] [int]$Value
  )
  if ($ReportOnly) {
    Write-Host "[Report] Would set HKLM:\$Path `$Name=$Value (DWORD)"
    return
  }
  if (-not (Test-Path "HKLM:\$Path")) { New-Item -Path "HKLM:\$Path" -Force | Out-Null }
  New-ItemProperty -Path "HKLM:\$Path" -Name $Name -Value $Value -PropertyType DWord -Force | Out-Null
  Write-Host "[OK] Set HKLM:\$Path `$Name to $Value"
}

function Enable-CertPaddingCheck {
  <# Tenable 166555 - CVE-2013-3900 mitigation #>
  Write-Host "`n=== 166555: Enabling WinVerifyTrust 'EnableCertPaddingCheck' ==="
  $paths = @(
    "SOFTWARE\Microsoft\Cryptography\Wintrust\Config",
    "SOFTWARE\WOW6432Node\Microsoft\Cryptography\Wintrust\Config"
  )
  foreach ($p in $paths) { Set-RegistryDword -Path $p -Name "EnableCertPaddingCheck" -Value 1 }
}

function Enable-SpeculativeExecutionMitigations {
  <# Tenable 132101 - Enable kernel/speculative mitigations (Spectre/Meltdown) #>
  Write-Host "`n=== 132101: Enforcing speculative execution mitigations ==="
  # When FeatureSettingsOverride = 0 and Mask = 3, mitigations are fully enabled.
  $base = "SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management"
  Set-RegistryDword -Path $base -Name "FeatureSettingsOverride" -Value 0
  Set-RegistryDword -Path $base -Name "FeatureSettingsOverrideMask" -Value 3

  # (Optional) VBS/CFG policy knobs can vary by OS; we stick to core CPU mitigations here.
  Write-Host "Note: A reboot may be required for CPU mitigations to take effect."
}

function Enforce-SMBSigning {
  <# Tenable 57608 - Require SMB signing on server and client #>
  Write-Host "`n=== 57608: Enforcing SMB signing (server + client) ==="
  # Server service (LanmanServer)
  $svr = "SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters"
  Set-RegistryDword -Path $svr -Name "RequireSecuritySignature" -Value 1
  Set-RegistryDword -Path $svr -Name "EnableSecuritySignature"  -Value 1

  # Workstation service (LanmanWorkstation)
  $cli = "SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters"
  Set-RegistryDword -Path $cli -Name "RequireSecuritySignature" -Value 1
  Set-RegistryDword -Path $cli -Name "EnableSecuritySignature"  -Value 1

  Write-Host "Note: Restart of 'LanmanServer' and 'LanmanWorkstation' services (or reboot) recommended."
}

function Handle-SSLTrustIssues {
  <# Tenable 57582 & 51192 - Self-signed / untrusted certificate issues #>
  Write-Host "`n=== 57582/51192: Addressing certificate trust ==="

  # 1) Refresh Microsoft trusted roots via Windows Update (creates SST and imports)
  $sst = Join-Path $env:TEMP "microsoft-ssl-roots.sst"
  if ($ReportOnly) {
    Write-Host "[Report] Would refresh root store from Windows Update and import roots."
  } else {
    try {
      Write-Host "Refreshing root store from Windows Update (this can take a moment)â€¦"
      certutil -generateSSTFromWU $sst | Out-Null
      $store = New-Object System.Security.Cryptography.X509Certificates.X509Store("Root","LocalMachine")
      $store.Open("ReadWrite")
      $collection = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2Collection
      $collection.Import($sst)
      $store.AddRange($collection)
      $store.Close()
      Remove-Item $sst -ErrorAction SilentlyContinue
      Write-Host "[OK] Root store refreshed."
    } catch {
      Write-Warning "Root refresh failed: $($_.Exception.Message)"
    }
  }

  # 2) Detect self-signed machine certs in LocalMachine\My (report or optionally replace)
  $certs = Get-ChildItem -Path Cert:\LocalMachine\My | Where-Object { $_.Issuer -eq $_.Subject }
  if ($certs) {
    Write-Host "Found self-signed certificates in LocalMachine\My:"
    $certs | ForEach-Object { Write-Host (" - {0}  Thumbprint:{1}" -f $_.Subject, $_.Thumbprint) }
    if ($ReplaceSelfSignedCerts -and -not $ReportOnly) {
      foreach ($c in $certs) {
        try {
          Write-Host "Replacing self-signed cert: $($c.Subject)"
          # Create a new self-signed (at least SHA256). NOTE: Services using these certs must be re-bound manually.
          $new = New-SelfSignedCertificate -DnsName $env:COMPUTERNAME -CertStoreLocation Cert:\LocalMachine\My -KeyLength 2048 -HashAlgorithm SHA256 -KeyExportPolicy Exportable -NotAfter (Get-Date).AddYears(1)
          # (Optional) You can add logic to re-bind IIS/RDP/etc. if you know the service and binding.
          # Remove old cert
          Remove-Item "Cert:\LocalMachine\My\$($c.Thumbprint)" -Force
          Write-Host "[OK] Issued replacement cert: $($new.Thumbprint)"
        } catch {
          Write-Warning "Replacement failed for $($c.Thumbprint): $($_.Exception.Message)"
        }
      }
      Write-Host "IMPORTANT: Re-bind services (IIS bindings, RDP listener, etc.) to the new certificate(s)."
    } else {
      Write-Host "Tip: Provide a CA-issued certificate and bind it to services using it to fully remediate trust findings."
    }
  } else {
    Write-Host "No self-signed certificates found in LocalMachine\My."
  }
}

function Block-ICMPTimestamp {
  <# Tenable 10114 - Block ICMP Timestamp (types 13 and 14) inbound/outbound #>
  Write-Host "`n=== 10114: Blocking ICMP Timestamp (types 13/14) ==="
  $rules = @(
    @{ Name="Block ICMPv4 Timestamp In";  Dir="Inbound";  Proto="ICMPv4"; Type=13 },
    @{ Name="Block ICMPv4 Timestamp Out"; Dir="Outbound"; Proto="ICMPv4"; Type=13 },
    @{ Name="Block ICMPv4 Timestamp Reply In";  Dir="Inbound";  Proto="ICMPv4"; Type=14 },
    @{ Name="Block ICMPv4 Timestamp Reply Out"; Dir="Outbound"; Proto="ICMPv4"; Type=14 }
  )
  foreach ($r in $rules) {
    $exists = Get-NetFirewallRule -DisplayName $r.Name -ErrorAction SilentlyContinue
    if ($exists) { 
      Write-Host "[Skip] Firewall rule exists: $($r.Name)"
      continue
    }
    if ($ReportOnly) {
      Write-Host "[Report] Would create firewall rule: $($r.Name)"
    } else {
      New-NetFirewallRule -DisplayName $r.Name -Direction $r.Dir -Protocol $r.Proto -Action Block -ICMPType $r.Type | Out-Null
      Write-Host "[OK] Created firewall rule: $($r.Name)"
    }
  }
}

function Test-PendingReboot {
  $rebootKeys = @(
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending",
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired",
    "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\PendingFileRenameOperations"
  )
  foreach ($k in $rebootKeys) {
    if (Test-Path $k) { return $true }
  }
  return $false
}

try {
  Assert-Admin
  Start-RemediationLog

  Write-Host "Starting remediation. Report-only mode: $ReportOnly`n"

  Enable-CertPaddingCheck
  Enable-SpeculativeExecutionMitigations
  Enforce-SMBSigning
  Handle-SSLTrustIssues
  Block-ICMPTimestamp

  if (Test-PendingReboot) {
    Write-Warning "A reboot appears to be pending. For kernel/SMB/cert changes to fully apply, please reboot."
  } else {
    Write-Host "No reboot pending was detected, but a reboot is recommended after these changes."
  }

} finally {
  try { Stop-Transcript | Out-Null } catch {}
  if ($TranscriptPath) { Write-Host "`nLog saved to: $TranscriptPath" }
}
